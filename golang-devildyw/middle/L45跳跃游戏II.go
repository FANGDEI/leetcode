package main

func main() {

}

// 每次跳跃，我们都尽量在当前能跳的范围内，延伸出下一次能到的最远边界
// 比如第一步跳到了2那么我们的最远边界就是2，我们能跳的范围就是[1,2]，我们在这个范围内找到下次跳跃能到达的最远边界
// 如果已经超过了这一次跳跃的范围了 那么我们就要开启新的一次跳跃 更新下次跳跃的边界 反复 直到我们到达终点
// 记住只有超过了范围才需要一次新的跳跃

func jump(nums []int) int {
	var (
		jumps    = 0 // 跳跃次数
		end      = 0 // 当前能跳到的边界
		farthest = 0 // 下一步能到的最远位置
	)

	// 最后一格不用跳
	// 在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，
	// 否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，
	// 我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。
	for i := 0; i < len(nums)-1; i++ {
		farthest = max(farthest, i+nums[i]) // 遍历过程中更新当前范围内能到达的最远边界
		if i == end {                       // 如果i已经到达本层边界了
			jumps++        //需要新跳跃一次
			end = farthest //同时更新边界为本层能到达的最远边界
		}
	}
	return jumps
}
